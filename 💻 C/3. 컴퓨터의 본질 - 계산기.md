#### 컴퓨터의 등장 목적
```
현재든, 과거든 컴퓨터가 등장하고 컴퓨터에게 요구하는 가장 핵심적인 역할은 누가 뭐래도, 빠르고 정확한 계산이다.
인간이 할 수 없는 복잡한 수식을 계산하는 것이야 말로 컴퓨터를 만든 가장 큰 목적인 것이다.
```

#### 연산자의 필요성
```
C언어에서 컴퓨터에게 연산 명령을 내리려면 연산자를 알아야 한다.
```

#### C 컴파일러의 대입 연산자 처리
```
C언어 컴파일러는 =라는 연산 기호를 뒤에서부터 해석한다.
그렇기 때문에 a = 10은 10을 a에 대입하라고? 알겠어하고 대입하지만
10 = a는 a를 10에 대입할 수 없기 때문에 오류가 발생하는 것이다.
```

![image](https://github.com/user-attachments/assets/7ef851f0-a32c-4e40-a40c-667d82870b71)
- 5를 d에, d를 c에, ... 줄줄이로 대입하면 결국 a = 5, b = 5, c= 5, d = 5를 한 것과 완벽하게 동일한 문장이 된다.

#### C 컴파일러의 산술 변환
```
int 형인 a / double 형인 b를 하면 결과는 무엇이 될까?
정답은 double 형이 된다.

그 이유는 컴파일러는 자료형이 다른 두 변수를 연산할 때 범위가 더 큰 자료형으로 형을 변환한 후 연산을 하기 때문이다.
int 형은 4바이트, double형은 8바이트인데 int로 변환한다면? double의 4바이트가 손실될 것이다.

그렇기 때문에 손실을 최소화하는 방향으로 자동 변환 후 연산이 진행되게 된다.
```

#### 비트 이동 연산 
```
비트를 왼쪽 시프트 연산하면 좌측으로 시프트 된 숫자는 갈 자리가 없으면 버려지지만 우측 비트는 0으로 채워진다.
101011 << 1 -> 010110
비트를 우측 시프트 연산하면 우측으로 시프트 된 숫자가 갈 자리가 없으면 버려지지만 좌측 비트는 맨 왼쪽에 있던 수가 채워진다.
11100010 >> 3 -> 11111100, 00011001 >> 3 -> 00000011

이는 좌측으로 비트 연산을 할 때는 빈 공간을 채울 때 조건의 영향을 받지 않기 때문이고,
우측으로 비트 연산을 할 때는 기존의 가장 좌측에 있던 부호 비트를 그대로 유지하기 위해서이다.
```


![image](https://github.com/user-attachments/assets/e716a438-cc29-481a-9272-236c44dd035f)
